\documentclass[oribibl]{llncs}

\usepackage{units}
\usepackage{psfrag} %% psfrac does not work with pdflatex
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{subfigure}
\usepackage{todonotes} %% add [disable] to disable
\usepackage{transparent}
\usepackage{pgfplots}
\usepackage{gensymb} %% \degree

\usepackage{acronym} %% for abbreviations
%% physics related abbreviations
\acrodef{DFT}[DFT]{density functional theory}
\acrodef{XC}[XC]{exchange-correlation}
\acrodef{SHO}[SHO]{spherical harmonic oscillator}
\acrodef{DOS}[DoS]{density of states}
\acrodef{HO}[HO]{harmonic oscillator}
\acrodef{PW}[PW]{plane wave}
\acrodef{GP}[GP]{grid point}
\acrodef{AE}[AE]{all-electron}
\acrodef{PAW}[PAW]{Projector Augmented Wave}
%% computer science related abbreviations
\acrodef{CPU}[CPU]{central processing unit}
\acrodef{GPU}[GPU]{graphical processing unit}
\acrodef{HPC}[HPC]{high performance computing}
\acrodef{OMP}[OpenMP]{OpenMP}
\acrodef{MPI}[MPI]{message passing interface}
\acrodef{SCF}[SCF]{self-consistent field}


\setlength{\tabcolsep}{6pt}

\newcommand{\um}[1]{_{\mathrm{#1}}}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\lmax}{\ell_{\mathrm{max}}}
\newcommand{\ellm}{L}
\newcommand{\nrn}{n_{\mathrm{r}}}
\newcommand{\ket}[1]{\left| #1 \right\rangle}
\newcommand{\bra}[1]{\left\langle #1 \right|}
\newcommand{\braket}[2]{\left\langle \left. #1 \right| #2 \right\rangle}
\newcommand{\braketop}[3]{\left\langle \left. #1 \right| #2 \left| #3 \right. \right\rangle}
\newcommand{\fullcodename}{\AA{}ngstr\"{o}mCube}
\newcommand{\codename}{A43}

\begin{document}
\pagestyle{plain}

\title       {\fullcodename{} User Manual}
\titlerunning{\codename{} User Manual}

\author{%
  Paul F.~Baumeister\inst{1} % \and %
}

\institute{%
  J\"{u}lich Supercomputing Centre, Forschungszentrum J\"{u}lich, 52425 J\"{u}lich, Germany
%   \and Institute for Advanced Simulation, Forschungszentrum J\"{u}lich, 52425 J\"{u}lich, Germany
}

\maketitle

\begin{figure*}
	\centering
	\includegraphics[width=3cm]{fig/a43_logo_bold_no_helper_lines} %%
\end{figure*}

% ==============================================================================
\begin{abstract}
This is a user manual for everyone who is interested in using
this software.
As far as possible, all aspects of programming are omitted here.
However, some aspects related to the algorithms that the applications 
makes use of will need be covered in order to explain the handling.
\end{abstract}
% ==============================================================================

\section*{How to read this document?}
\todo[inline]{Write}

\newpage
% ==============================================================================
\section{Introduction} \label{sec:intro}
% ==============================================================================
%
\codename{} is an implementation for performing calculations 
in the framework of \ac{DFT}.
Readers familiar with the theory may jump to the description of 
features of \codename{} in Section \ref{sec:features}.

\subsection{Density Functional Theory} \label{sec:short-theory}
%
A fair number of books and a vast number of articles in the scientific 
literature is on \ac{DFT}, therefore, we will only give a brief recap 
of the very basics needed to understand what kind of physics can be
simulated with \codename{} and also, where the limitations of predictive power
are.

\ac{DFT} is a ground state method, this means that in principle we have to
assume zero Kelvin. However, you will see later that for special situations 
finite temperatures are applied to smear out the Fermi-Dirac distribution 
for electronic occupation numbers in order to improve convergence.
In principle, all results should be extrapolated to \unit[0]{K}.


The underlying Hohenberg-Kohn theorem tells us, that we can derive some 
ground state properties of the system once we have found the correct density.
In order to find the density, Kohn and Sham introduced single-particle wave functions $\Psi_i$, 
which are eigenstates of an effective single-particle Hamiltonian $\hat H$.
With a little simplification, we can write the total electron density
\begin{equation}
	n(\vec r) = \sum_i^{\mathrm{occ}} \left| \Psi_i(\vec r) \right|^2
	\label{eqn:simplified_density_generation}
\end{equation} 
As a function or functional of the density $n(\vec r)$ we can construct
a local effective potential entering the Hamiltonian
\begin{equation}
	\hat H\um{Kohn-Sham} = \frac{\left( \imath \hbar \vec \nabla \right)^2}{2 m_e} + V\um{eff}(\vec r)
	\label{eqn:Kohn-Sham_Hamiltonian_no_spin}
\end{equation} 
where $V\um{eff}(\vec r)$ includes
\begin{itemize}
  \item the attractive Coulomb potential of the atomic nuclei,
  \item a repulsive Hartree potential from electrostatic 
  		interaction of an electron with the density,
  \item potential external fields and
  \item a contribution accounting for exchange and electronic correlation.
\end{itemize}

\subsection{The Exchange-Correlation Functional} \label{sec:xc-functional}
%
The true many-body wave function for a system with electrons (as being Fermions)
is anti-symmetric under exchange of two particles. 
This implies that e.g.~a two-electron wave function $\Psi(\vec r_1,\vec r_2)$ must be zero 
whenever $\vec r_1 \rightarrow \vec r_2$ in order to obey the anti-symmetry constraint.
This lowers the repulsion energy of a real two-electrons system compared to a
system of independent charged particles.
Different from the Hartree-Fock method where a Slater determinant takes care of the antisymmetry exactly
in \ac{DFT} the construction of independent single-particle states 
is an approximation that requires to model the exchange interaction.

Furthermore, there are correlation effects of true many-body electron systems
which also need to be modelled in both, \ac{DFT} and Hartree-Fock.
Exchange and correlation effects together are modelled in the contribution $V\um{xc}(\vec r)$ 
to the total effective potential and a corresponding energy density $\epsilon\um{xc}$ for the evaluation of a total energy.

Different parametrizations of the \ac{XC} functional are available.
\codename{} focusses onto the three classes of (semi-)local, non-orbital dependent functionals: 
\begin{itemize}
	\item Local (Spin) Density Approximation, LDA/LSDA, 
	\item Generalized Gradient Approximation, GGA
	\item Meta-GGA
\end{itemize}
LDAs generate $V(\vec r)$ only from the value of $n(\vec r)$, 
hence the name \emph{local}. 
GGAs include some gradients of the density, $|\vec \nabla n(\vec r)|$.
Still, the spatial argument $\vec r$ is the same but thinking for example
in terms of finite-difference derivatives on a grid, 
a little non-local character of GGAs becomes visible.
Finally, meta-GGAs incorporate information about the kinetic energy density.
In analogy to eq.~(\ref{eqn:simplified_density_generation}), the kinetic energy density $\tau$ can be found by
\begin{equation}
	\tau(\vec r) = \frac{\hbar^2}{2m_e} \sum_i^{\mathrm{occ}} \braketop{ \Psi_i } {\vec \nabla^2 } { \Psi_i } 
	\label{eqn:simplified_kinetic_energy_density_generation}
\end{equation}
where we introduced Dirac's \emph{bra-ket} notation.
Currently, only the 
%Perdew-Zunger'81 \ttt{PZ81}
Perdew-Wang'91 \ttt{PW91}-LDA is implemented
but it is planned to interface \ttt{libxc} with access to most existing functionals.
\todo[inline]{Implement LIBXC, reference for LIBXC}

\subsection{Code Features} \label{sec:features}
%
\codename{} is an all-electron \ac{DFT} application 
based on the \ac{PAW} method \cite{PhysRevB.50.17953} % Bloechl 1994
with the extension of analytical projectors \cite{BaumeisterTsukamoto2019}
where the projectors are eigenfunctions of a \ac{SHO}.
\ttt{C++} has been chosen for its expressivity
when it comes to mult-precision algorithms 
and its good interoperability with common \ac{GPU} programming models.

\noindent
For an up-to-date list of the code features, please see the \ttt{README.md} file.

\section{How to get started} \label{sec:how-to-get-started}
%
\subsection{Getting the Code} \label{sec:getting-the-code}
\codename{} will be public domain software under the MIT license
and will be available to clone, fork or download at \ttt{github.com/real-space/A43}. 
\todo[inline]{move to GitHub}

\subsection{Building the Application} \label{sec:compiling}
%
A \ttt{Makefile} is contained in the program package that works with current compilers, e.g.~\ttt{GNU c++ 7.4.0} or \ttt{clang 11.0.0}.
\todo[inline]{get CMake to work}
%% and \ttt{nvcc from CUDA 10}

The application \codename{}, while being written in C++, strongly relies on plane-old-data types,
i.e.~classes without constructors or destructors as known from C-structs.
Furthermore, it makes use of generic programming in the form of templates
mainly used to maintain a single function supporting different precision (\ttt{float} or \ttt{double}), 
difference vector lengths, \ttt{real} and \ttt{complex} and in some situations different physics.
This helps to keep the code base small and, hence, maintainable.

\section{Basic Handling} \label{sec:basic-handling}
%
\fullcodename{} or short \codename{} comes as a single executable named \ttt{a43} which
offers many functionalities accessible by options. Type \ttt{./a43 -h}
to get a first help function:
\begin{verbatim}
Usage ./a43 [OPTION]
   --help           [-h]	This help message
   --version            	Show version number
   --test <module>  [-t]	Run module unit test
   --verbose        [-V]	Increment verbosity level
   +<name>=<value>      	Modify variable environment
\end{verbatim}

An important functionality after building the application (see Section \ref{sec:compiling})
is to run the unit tests of the available modules.
In order to get a list of available modules, use 
\begin{verbatim}
./a43 -t '?'
\end{verbatim}
where the high quotes are necessary so your shell does not try to interpret the question mark.
Pass the name of one of the listed modules to run a module unit test like this:
\begin{verbatim}
./a43 -t complex_tools
\end{verbatim}
We can also run the unit test of all modules, however, for this we might want to reduce
the amount of output to \ttt{stdout}.
We may use the variable environment 
\footnote{The internal variable environment of this \codename{} is not linked to that of the shell.}
which couples to the command line interface with a leading \ttt{+}. For example use
\begin{verbatim}
./a43 +verbosity=1 -t
\end{verbatim}
to change the \ttt{verbosity} to minimal when running all unit tests. Table \ref{tab:verbosity-level-meaning} shows \ttt{verbosity} ranges in detail.

\todo[inline]{Ensure that all modules have some meaningful unit tests or at least say it that they don't}

The default \ttt{verbosity}-level is $3$ and levels are adjusted occasionally during development.
However, the ground rule says that higher \ttt{verbosity} means more output
and \ttt{verbosity=0} suppresses all output except for fatal errors.
We can also use the options \ttt{--verbose} to set \ttt{verbosity=6} (high)
or fine tune the verbosity level by adding +$1$ for every \ttt{-v} and +$4$ for every \ttt{-V}.
Table \ref{tab:verbosity-level-meaning} gives a rough overview on verbosity levels. 

\begin{table}[ht!]
\caption[Meaning of verbosity levels]{
Meaning of verbosity levels
\todo[inline]{Is this table needed?}
} \label{tab:verbosity-level-meaning}
\centering
\begin{tabular}{|r|l|}
\hline
  \ttt{verbosity} & Meaning   \\
\hline
     0 & No output whatsoever \\
     1 & Minimal output       \\
     3 & Default low          \\
  5--7 & High detail          \\
   $\geq$ 8 & Debugging       \\
\hline
\end{tabular}
\end{table}


\subsection{Atomic Units, Input and Output} \label{sec:units}
%
Internally \codename{} makes use of Hartree atomic units:
\begin{equation}
	\hbar = m_e = e = 1
\end{equation}
as this reduces the number of non-trivial factors in many equations.
This means that the internal unit of length is Bohr = \unit[0.529177]{\AA{}}
and the internal unit of energy is Hartree = \unit[27.2114]{$e$V}.
However, we can change the length and energy units used for output like this:
\begin{verbatim}
./a43 +output.energy.unit=eV +output.length.unit=Ang ...
\end{verbatim}
%% sigma_config uses Bohr always (as input and output unit) on purpose
Available output units are \ttt{eV}, \ttt{Kelvin}, \ttt{Ry} or \ttt{Ha} (default in the development branch) for energies 
and \ttt{nm}, \ttt{pm}, \ttt{Ang} (=\AA) and \ttt{Bohr} (default) for lengths. Run
\begin{verbatim}
./a43 -t unit_system
\end{verbatim}
to verify this.
%
Input length units are \AA{} in the \ttt{geometry.file} as this is most convenient for molecular structure viewers
(\ttt{VESTA}, \ttt{jmol}, etc). Other input quantities may have flexible input units, for example
\begin{verbatim}
./a43 +logder.unit=Ry +logder.step=1e-3
\end{verbatim}
which means that the energy spacing for checking of the logarithmic derivatives is \unit[$10^{-3}$]{Rydberg}.
The same input unit is assumed for \ttt{+logder.start} and \ttt{+logder.stop}.


Experimental parts of the code may not support the flexible unit conversion
factors for output. Then you should be able to find at least indications as \ttt{Ha}, \ttt{Bohr} or simply \ttt{a.u.} in the log files.
Most standard functionality, however, supports unit conversion so that log files
show \ttt{eV} or \ttt{Ry} and \ttt{Ang}$ = $\AA{} or \ttt{nm}, depending on the users choice.
Some quantities are displayed in characteristic units, e.g., plane wave cutoffs are typically shown in Rydberg.


\subsection{Try a first structure} \label{sec:first-steps}
%
Make sure there is \ttt{jmol}-viewable structure file \ttt{atoms.xyz}
with atomic coordinates given in \AA{} and run
\begin{verbatim}
./a43 -t geometry_analysis
\end{verbatim}
in order to check if your geometry looks ok.
More details on what the geometry analysis output tells you can be found in Section \ref{sec:geometry-analysis}.
You can search the log file for warnings using \ttt{grep} but
there will also be a summary of all warnings launched during execution at the end of the log file.
For a detailed description of the usage of \ttt{geometry\_analysis} see Section \ref{sec:geometry-analysis}.
%
\noindent
Once free of warnings, continue with the next step:
Let's say we want aluminum in our system, then run:
\begin{verbatim}
./a43 -t single_atom +single_atom.test.Z=13
\end{verbatim}
See Section \ref{sec:single-atom} for more details on \ttt{single\_atom}.
\todo[inline]{Currently, aluminum produces a critical charge deficit operator eigenvalues}
%
\codename{} will then try to access a database of initial atomic potentials
(full spherically, spin-degenerate) which are stored in \ttt{./pot/Zeff.}$Z$
where $Z$ is a 3-digit integer atomic number.
\todo[inline]{make the path to pot/ configurable}
You can even add \ttt{+single\_atom.init.scf.maxit=33} to let the atomic density relax if e.g.~the \ac{XC} functional differs from the one that was used to generate the \ttt{Zeff.}-file.
If the loading fails because of a missing file, you can bootstrap it:
\todo[inline]{check again, there should be automatic bootstrapping}
\begin{verbatim}
./a43 -t atom_core +atom_core.test.Z=13
\end{verbatim}
or if the entire database was lost,
\begin{verbatim}
./a43 -t atom_core \
        +atom_core.test.Z=1 +atom_core.test.Z.end=86
\end{verbatim}
This may take some minutes. To track the progress, \ttt{+verbosity=5} is recommended.
More details on \ttt{atom\_core} can be found in Section \ref{sec:atom-core}.
\todo[inline]{OpenMP would be good here}
%
\noindent
Now, run the \ttt{single\_atom} test for each of the elements in the system 
to see if there are warnings before you continue with the main calculation
\begin{verbatim}
./a43 -t self_consistency \
        +geometry.file=molecule.xyz
\end{verbatim}
\todo[inline]{we have not yet defined a functionality of main! only tests so far}
%

%
\subsection{Writing an input file} \label{sec:control-file}
%
At some point the command line becomes full.
We can pass more environment variables to \codename{} using a \ttt{control.file}, e.g.:
\begin{verbatim}
./a43 -t potential_generator +control.file=control.sh
\end{verbatim}
Hint: There is no default name or naming scheme for the control file 
but it may be helpful to use an \ttt{.sh}-file extension since that
enables useful syntax highlighting in common text editors.
%
%

\subsubsection{Control File Rules} \label{sec:control-file-rules}
%
Lines in a control file are either 
\begin{itemize}
    \item empty
    \item silent comments starting from \ttt{\#}
    \item comments with \ttt{\#!} which appear in the log output or
    \item $variablename$\ttt{=}$value$
\end{itemize}
where $value$ is the string between \ttt{=} and the line end and may contain whitespace characters.
\\
Mind: We must not place \ttt{+} in front of $variablename$ when specified in a control file!
We may add blanks after \ttt{=} for numeric values but not before it.
\\
A repeated $variablename$ will launch a warning about redefinition.
%
%

\subsubsection{List of Control Variables}
%
Use e.g.~\ttt{+control.show=1} to display all used environment variables used during a successful execution.
Set \ttt{+control.show=2} to show only the unused variables, \ttt{4} for those variables have their default values, \ttt{6} for both.
In order to get information where the variable's value originated and how many times it was used, invert the same number as above into their negatives, i.e.~\ttt{-1}, \ttt{-2}, \ttt{-4} and \ttt{-6}.
See Tab \ref{tab:control-show-details} for decoding. 
%
%
\begin{table}[ht!]
\caption[Variable value origins]{
Variable value origins
} \label{tab:control-show-details}
\centering
\begin{tabular}{|l|l|}
\hline
  	 \ttt{Detail}    & Meaning   \\
\hline
     \verb+def  0+   & Variable has its default value      \\
     \verb+set  0+   & Value was set using \ttt{control::set()} \\
     \ttt{argv \#}   & Command line argument number \\
     \ttt{line \#}   & Line number in the \ttt{control.file} \\
\hline
\end{tabular}
\end{table}


\subsection{Parallel Computing} \label{sec:parallelization}
%
Currently, only the \ttt{geometry\_analysis} part of \codename{} supports shared memory parallelism 
via \ac{OMP} threads on the \ac{CPU}.
In order to target current \ac{HPC} systems 
the goal is to incorporate the \ac{MPI}
for inter-node communication
and the \ttt{CUDA} programming model for acceleration by a \ac{GPU}.
\todo[inline]{MPI parallelize}
\todo[inline]{Import CUDA finite-difference from ReSpawN}
\todo[inline]{Import CUDA sho-transform from ReSpawN}
\todo[inline]{Import CUDA tfqmr from tfQMRgpu}

\noindent
Please consult with your \ac{HPC} system administrator for support
about how to control the different levels of parallelism.

\section{Representation of Wave Functions} \label{sec:representation}
%
Kohn-Sham eigenstates have very different character depending on their energy level: core states, valence states and depending on the species also semicore states.
%
%
\subsubsection{Treatment of Core States} \label{sec:core-states}
%
Core states are very low in energy and strongly bound 
to the atomic core.
Their spatial extent is so strongly localized 
in the vicinity of the atomic nucleus 
that they feel almost exclusively the strong attractive 
(effective because screened) Coulomb potential of the core. 
This can be approximated fairly well as a spherically symmetric potential.
with a singularity at its origin.
The eigenstates show a clear $\ell$-character, 
i.e.~$s$, $p$, $d$ or even $f$ states can be found.
Technically, the solutions are found on a 1D radial grid,
where also relativistic effects can be treated properly.
The energy is well defined and degenerate with respect to
the magnetic quantum number $m$.

%
%
\subsubsection{Treatment of Semicore States} \label{sec:semincore-states}
%
Semicore states are high-lying core states
but energy-wise below the valence band.
Their wave function tail can extend beyond half a nearest neighbor atom distance.
In a tight-binding picture, the hoppings to the neighboring atom are still small
but the non-sphericality of the potential becomes important.
The $m$-degeneracy of the energy (found for core states) breaks 
and crystal field splittings or even bands with small dispersion can be observed.
\todo[inline]{Implement semicores}
It is planned to implement semicore states with a separate energy window
and either tight-binding like derived from atomic orbitals 
(eigenfunctions of the spherically averaged potential) 
or with a full \ac{PAW} treatment as follows for the valence states.

%
%
\subsubsection{Treatment of Valence States} \label{sec:valence-states}
%
Valence states are high in energy, by definition up to the Fermi
energy, are delocalized over several atoms and form bands and bonds.
They are particularly difficult to describe because of the 
inhomgeneiety of features:
Valence states exhibit relatively slow oscillations 
in the space between atoms (interstitial space) but close to the atomic nuclei,
their structure resembles that of high-lying core states.
In particular projected radial coordinates, we can find up to $6$ nodes
(7$s$-bands) with the distance between the nodes becoming smaller
the closer we move towards the core.
These rapid oscillations are difficult to represent
on the same footing that gets the behaviour in the interstitial regions correct. 
We will review some of the most common approaches:

Local orbital methods use radial eigenfunctions 
of the spherically averaged atomic potential as atom-centered basis functions.
This captures the behaviour in the core region well
but shows a slow and not systematic convergence behaviour in the interstitial region. 
An advantage is that atomic orbital basis sets can be rather compact
and localized which casts the Hamiltonian into a block-sparse matrix operator with small block dimensions ($\approx 30$).
The drawback is that the description in the interstitial region determines the
quality of description for bandstructures, bonds and forces.

LAPW (Linearized Augmented Plane Wave) methods take the best of two worlds:
In order to construct efficient basis functions, 
they assume a spherical potential inside an atomic sphere (solutions are radial)
and a constant potential inside the interstitial region (solutions are plane waves). 
On the boundary spheres between the two regions, the basis function components need to be matched.
Due to the \ac{PW}-character, the basis functions are fully delocalized and 
the Hamiltonian becomes dense.

Using \ac{PW}s as a basis for the entire space shifts the problem to the representation of the valence wave function in the core region.
The \ac{PAW} method is a successful generalization of the family of pseudopotential methods with allows a full-potential access.
A pseudopotential replaces the true deep full potential in the core region
by some potential which can be represented with a finite number of \ac{PW}s
and approximates the scattering properties (phase shifts) in the typical energy
range of valence states.
In most cases the construction of such a potential only succeeds in the form of
a non-local potential.

Real-space grid based methods for \ac{DFT}
feature an improved scalablity on massively parallel \ac{HPC} systems at the same level of accuracy as \ac{PW} basis sets. 
The \ac{PAW} method can be utilized and comes at the advantage that the projector functions are localized around the atoms, 
hence, the Hamiltonian becomes an implicit low-rank operator with sparsity which does not involve Fourier transforms when applied to a wave function.


\codename{} implements Cartesian real-space grids 
in combination with a revision of the \ac{PAW} method (revPAW) suitable for
a reduced memory capacity consumption and lower memory bandwidth requirements.
\todo[inline]{cite Baumeister, Tsukamoto, PASC19 proceedings}



\section{Geometry Analysis Tool} \label{sec:geometry-analysis}
%
The geometry file (\ttt{geometry.file=atoms.xyz}) is a file
holding three items:
the number of atoms, 
a comment line which specifies the rectangular cell parameters in \AA{}, 
and the atomic coordinates in \AA{} as
\begin{verbatim}
    2
    #cell 10.6 10.6 12.7 periodic periodic periodic
    Al   0 0 -1.05835
    P    0 0  1.05835
\end{verbatim}
It can be viewed by \ttt{Jmol}-viewer \cite{jmol-software}.
%
\noindent
To check if your coordinate file is parsed correctly run
\begin{verbatim}
./a43 -t geometry_analysis
\end{verbatim}
providing a rich log output about interatomic distances,
potential bonds and atomic coordination. The following section
explain the analysis results in more detail.

\subsection{Distance Histogram} \label{sec:distance-histogram}
%
At increased \ttt{verbosity} a distance histogram is generated with
a bin width of \ttt{+geometry\_analysis.bin.width} which is set to \unit[0.02]{\AA} by default.
The geometry analysis algorithm checks on every pair of atoms
including the effect of periodic images.
For geometries with many atoms in the simulation volume
a naive $\mathcal O(n\um{atoms}^2)$-algorithm 
leads to unaffordable compute requirements.
Hence, an $\mathcal O(n\um{atoms})$-algorithm has been implemented, see \cite{a43theory}.
For this, we define a maximum range $R$ controlled 
by \ttt{+geometry\_analysis.max.range} which is \unit[6.5]{\AA} by default.
The simulation cell is subdivided into rectangular boxes. 
Each box edge must be longer than $R$. 
The atoms are sorted into their corresponding boxes.
With this, atoms of each box must only check their distances 
with atoms of the adjacent $3^3$ boxes.
% \todo[inline]{Enrich the theory chapter about the theoretical crossover}
The range $R$ defines a natural upper end for the distance histogram.
A sparse representation of the distance histogram will be found in the log output.
This means that sequences longer than two bins where all entries are zero are not shown.
However, when plotted with solid lines, there is no difference.
Search the log for \ttt{\#\# distance histogram} to find the legend:
The first column is the distance value of the bin in your chosen \ttt{output.length.unit}.
The following columns represent all combinations of species.

\subsection{Bond Structure Analysis} \label{sec:bond-structure-analysis}
%
Find \ttt{\# bond structure analysis} in the log.
For particularly large systems, even one line per atom
can lead to very large log files which no human wants to read.
Therefore, statistical summaries 
for \ttt{\#\# bond angles} 
and \ttt{\#\# bond distances} are displayed at the end.
The per-atom output can be suppressed
by \ttt{+geometry\_analysis.show.bond.structure=0} or a low \ttt{verbosity}.
If the BSA is too memory consuming, you may limit it 
to the first \ttt{geometry\_analysis.max.atoms.with.partners} atoms 
or disable it entirely by \ttt{+geometry\_analysis.max.bond.partners=0},
however, summaries cannot be generated then.

\subsubsection{Bond Angles Histogram} \label{sec:bond-angle-histogram}
A histogram for \ttt{\#\# bond angles} is generated for each atomic species.
The bin width is 1\degree{} and the representation is sparse,
compare Section \ref{sec:distance-histogram}.

\subsubsection{Bond Distances Histogram} \label{sec:bond-distance-histogram}
A histogram for \ttt{\#\# bond distances} is generated for each atomic species.
The histogram parameters can be controlled by 
\ttt{geometry\_analysis.bond.bin.width} and 
\ttt{geometry\_analysis.bond.num.bins}. Default is $184$ bins with about $30$ bins per \AA{}.
The histogram representation is sparse, see above.
%% An example can be found here:
%% a43/doc/fig/Cu320Zr180_distance_hist.agr .pdf

\subsection{Summaries}
%
Atom-atom bonds and distances are summarised after the potentially lengthy log output described in
sections \ref{sec:distance-histogram} and \ref{sec:bond-structure-analysis}.
% , \ref{sec:bond-angle-histogram} and \ref{sec:bond-distance-histogram}.

A table of \ttt{coordination numbers} and their \ttt{occurrence} is given for each species.
The \ttt{\# half bond length} displays which radius has been taken to identify a bond.
The default bond length between two species is given by the sum of
the two \ttt{half bond length}s.
An interatomic distance below \ttt{geometry\_analysis.elongation=1.25} 
times the default bond length is recognized as a bond.
%
The user may customize the half bond length, e.g.~for copper 
by setting \ttt{geometry\_analysis.half.bond.Cu} in Bohr units.
%
All \ttt{\# bond counts} are listed in an upper diagonal matrix as function of the two
contributing species. Row/column sums show the total number of bonds for a given species.
Further, the upper diagonal form is also used to display
\begin{itemize}
	\item the minimal distance
	\item the longest bond and
	\item the shortest bond
\end{itemize}
between to atoms of a given pair of species.
The \ttt{\# shortest bond} should coincide with \ttt{\# min. distance}
and shows \ttt{n/a} in case there is no bond.
The minimal distance is displayed as \ttt{n/a} if the atom-atom distance exceeds $R$.
%
The information of the four matrix tables described above
is also contained in the \ttt{\# bond table}.
Where bonds have been detected, 
the average and root-mean-square of the bond lengths are displayed
in addition to minimum and maximum.
By \ttt{geometry\_analysis.show.all.pairs} defaults to \ttt{1}.
If the number of species in the system becomes large, setting this
parameter to \ttt{0} will suppress all entries with a \ttt{n/a} minimal distance from the table.
This is particularly helpful for the synthetic input case discussed in Section \ref{sec:many-species-test}.

%
%
\subsection{Many Species Test} \label{sec:many-species-test}
%
To test the full functionality of the geometry analysis,
we can generate a \ttt{+geometry\_analysis.test.file} 
with the default filename \ttt{species\_test.xyz}.
It contains \ttt{geometry\_analysis.test.nspecies} $\in [2, 128]$ atoms, each with a
different species, positioned in a chain. Running
\begin{verbatim}
./a43 -t geometry_analysis +verbosity=7 \
        +geometry_analysis.select.test=-1 \
        +geometry_analysis.test.nspecies=4 \
        +geometry.file=species_test.xyz
\end{verbatim}
will create the file, parse it and analyze its linear geometry.
Technically, one could increase \ttt{test.nspecies} up to \ttt{128},
however, the output is far from readable due to too many too long lines.
The interatomic distances are chosen such that most coordination numbers
are $2$ and all bond angles are 180\degree{}.
%

\newpage

\section{Advanced Controls} \label{sec:advanced-controls}
%
This part of the \codename{} manual describes
various modules in detail.

%\subsection{Fermi level} \label{sec:fermi-level}
%During an \ac{SCF} calculation, 
%the Fermi energy can be determined in two different ways:
%\begin{itemize}
%	\item \ttt{exact}
%	\item \ttt{linearized} and
%	\item external
%\end{itemize}

\subsection{Atomic Core} \label{sec:atom-core}
%
The \ttt{atom\_core} module determines a self-consistent solution
of a spherically symmetric, isolated atom with $Z$ protons in the core.
The resulting potential $V(r)$ is stored in \ttt{pot/Zeff.00}$Z$
in the form $-rV(r) = Z\um{eff}(r)$.
$Z\um{eff}(r)$ approaches $Z$ at the origin and goes to zero for large $r$.
To start an atomic calculation, run
\begin{verbatim}
./a43 -t atom_core
\end{verbatim}
The atomic number $Z$ can be controlled by \ttt{atom\_core.test.Z}.
If more than one element should be generated
the user can specify \ttt{atom\_core.test.Z.end} 
and a step size \ttt{atom\_core.test.Z.inc} which defaults to \ttt{1}, however,
non-integral values are permitted in all three parameters.
%
\noindent
For the atomic \ac{SCF} calculation, occupation numbers of the atomic orbitals are fixed
to predefined values. \ttt{atom\_core.occupations} can be chosen \ttt{auto}
or \ttt{custom} where they are taken from the element configuration, see Section \ref{sec:sigma-config}.


\subsection{Element Configuration} \label{sec:sigma-config-short}
%
A list of $120$ default element configuration is contained in the application.
For example the default configuration for aluminum can be displayed by
\begin{verbatim}
./a43 -t sigma_config +sigma_config.test.Z=13
\end{verbatim}
The user can modify the configuration string using the chemical symbol
\begin{verbatim}
./a43 -t sigma_config +element_Al="3s 2 3p 1 | 2.05 sigma .5" \
 		+sigma_config.test.Z=13
\end{verbatim}
where the high quotes are necessary only in the command line interface
and can be omitted in the control file, see Section \ref{sec:control-file-rules}.
%
\noindent
An element configuration string consists of
\begin{itemize}
	\item occupation numbers used for the isolated atom calculation
	\item a \ac{PAW} cutoff radius specified in Bohr after the \ttt{|} and
	\item a \ttt{sigma} parameter for the spread of \ac{SHO} projectors.
\end{itemize}

\subsection{PAW Potential} \label{sec:single-atom}
%
For the advanced user we recommend to inspect the logarithmic derivatives by
\begin{verbatim}
./a43 -t single_atom +single_atom.test.Z=13 \
        +logder.start=-4 +logder.step=1e-4 +logder.stop=1.0
\end{verbatim}
The output can be visualized by \ttt{gnuplot} or \ttt{xmgrace -nxy} $logfile$.
%
\noindent
For the ease of use, we may add \ttt{+logder.unit=eV} and then specify
\ttt{logder.start}, \ttt{logder.stop} and \ttt{logder.step} in units of $e$Volt.

\noindent
Logarithmic derivatives are summarized by the position of the resonances (poles).
For \ttt{+verbosity=8} and higher, the generalized node counts are given plottable in the log file.

\noindent
The \ttt{eigenstate\_analysis} tool solves the spherically symmetric pseudo atom
problem on an equidistant radial mesh. This allows to check for potential ghost states.
Increase \ttt{eigenstate.analysis.warn=.003 Ha} to suppress warnings.


\subsection{Self Consistency Iterations} \label{sec:self-consistency}
%
\begin{verbatim}
./a43 -t self_consistency
\end{verbatim}
takes several control variables, the most important ones are listed in Table \ref{tab:main-scf-variables}.
%
\begin{table}[h]
\caption[Main Variables]{
Most important variables to control self-consistency iterations in \codename{}.
} \label{tab:main-scf-variables}
\centering
\begin{tabular}{|l|r|l|}
\hline
  Variable Name & Default & Meaning, Alternatives \\
\hline
  \ttt{geometry.file} & \ttt{atoms.xyz}   & Atomic coordinates and cell \\
  \ttt{basis}         & \ttt{grid}        & Basis set, \ttt{plane\_wave}, \ttt{sho} \\ 
  \ttt{grid.spacing}  & \unit[0.125]{\AA} & Coarse real-space grid spacing \\
  \ttt{grid.eigensolver} & \ttt{CG}       & \ttt{Davidson}, \ttt{explicit}, \ttt{none} \\
  \ttt{plane\_wave.solver} & \ttt{auto}   & \ttt{direct}, \ttt{iterative}, \ttt{both} \\ 
  \ttt{plane\_wave.cutoff.energy} & \unit[11]{Ha} & Plane wave cutoff energy \\
  \ttt{check}         & \ttt{0}           & Dry run, \ttt{1}: preparations only \\
  \ttt{valence.electrons} & \ttt{auto}    & Total number of valence electrons \\
  \ttt{initial.valence.density} & \ttt{atomic} & Start density, \ttt{load}, \ttt{none} \\
  \ttt{hamiltonian.kmesh} & \ttt{1}       & Brillouin zone integration points \\
  \ttt{electrostatic.solver} & \ttt{fft}  & Coulomb solver, \ttt{multi\_grid}, \ttt{none} \\
  \ttt{bands.per.atom} & $10$ 			  & Number of eigenstates per atom \\
  \ttt{electronic.temperature} & \unit[315.8]{K} & Electronic smearing temperature \\
  \ttt{fermi.level}   & \ttt{exact}       & Fermi level method, \ttt{linearized} \\
  \ttt{self\_consistency.mix.density} & $0.25$ & Simple density mixing parameter \\
  \ttt{self\_consistency.max.scf} & $1$   & Max.~number of \ac{SCF} iterations \\
  \ttt{start.waves}   & -                 & Load wave functions from this file \\
  \ttt{store.waves}   & -                 & Store wave functions to this file \\
\hline
\end{tabular}
\end{table}
%
\todo[inline]{implement \ttt{store.density} and \ttt{load.density} from file}


\subsection{Brillouin Zone Integration} \label{sec:brillouin-zone}
%
A uniform $\vec k$-point mesh is implemented in \codename{}.
Use \ttt{hamiltonian.kmesh} with values larger than \ttt{1} to
specify an isotropic integer value or use
\ttt{hamiltonian.kmesh.x}, -\ttt{.y} and -\ttt{.z} 
to control each spatial direction separately.
If any direction is larger than $2$ points,
wave functions cannot be real-valued due to complex phase factors.
%
%

\subsection{Element Configuration} \label{sec:sigma-config}
%
The configuration of chemical elements contains various parts:
\begin{itemize}
  \item Occupation numbers for spherical calculations
  \item Orbital classification into \ttt{core}, \ttt{semicore} and \ttt{valence}
  \item \ac{PAW} generation parameters
\end{itemize}
%
\noindent
The configuration string for the details of the \ac{PAW} data set should be 
specified in each input file to make sure the results are the same. Run
\begin{verbatim}
./a43 -t sigma_config -v
\end{verbatim}
to check that all default configuration strings can be parsed without errors.
\\
To check only e.g.~stronium and show its configuration run
\begin{verbatim}
./a43 -t sigma_config +sigma_config.test.Z=38
\end{verbatim}
The configuration string can be specified as
\begin{verbatim}
element_Sr=4s 2 5s 2 4p* 6 4d | 2.37 sigma .666
\end{verbatim}
in the \ttt{control.file} or via the command line as
\begin{verbatim}
./a43 -t sigma_config +sigma_config.test.Z=38 \
        +element_Sr="4s 2 5s 2 4p* 6 4d | 2.37 sigma .666"
\end{verbatim}
The variable name \ttt{element\_}$Sy$ expects an element symbol $Sy$ 
like \ttt{Sr} for strontium or \ttt{S} for sulfur, case-sensitive, no blank between keyword and \ttt{=} sign.
In the electronic configuration string the orbital specifier \ttt{4s} sets the 4$s$-state to be 
included in the set of valence states. Automatically, 1$s$, 2$s$ and 3$s$ are set to 
be \ttt{core} states.
The \ttt{2} following \ttt{4s} represents an occupation number
and is, hence, interpreted as floating point number \ttt{2.0}.
It is used for the all-electron self-consistent isolated atom calculation in \ttt{atom\_core}, see Section \ref{sec:atom-core}
and for the relaxation of the atomic \ttt{core} and \ttt{semicore} states in \ttt{single\_atom}.
If no occupation number is given, the occupation is zero, if a single number is given,
both spin-channels are given half of the occupation and with two numbers
we define a magnetization, i.e.~majority and minority spin.

\noindent
Semicore state can be marked e.g.~by \ttt{4sSemicore 2}.
Similarly, core holes can be introduced by modifying the occupation numbers of
a \ttt{core} orbital, e.g.~\ttt{1sCore 1 0}.
Mind that previous versions of the parser supported e.g.~\ttt{3phole}
to specify how many electrons to subtract from the $3p$ core state occupation.
This is not supported any longer and aborts in an error.

\noindent
A second valence orbitals with the same angular momentum $\ell$ as in \ttt{element\_Sr=4s 2 5s 2} [...] 
effects that two partial waves are used for this $\ell$.
Additional partial waves can be added by asterisks as e.g.~in \ttt{element\_Os=6s* 2} [...].
Note that \ttt{element\_Sr=4s 2 5s*} [...] or \ttt{element\_Sr=4s* 2 5s} [...] %% ToDo: check this
would activate a third set of partial waves and projectors which is not recommended for reasons of stability.
The example of Osmium shows how the \ac{PAW} augmentation radius is specified after the vertical bar \ttt{|}.
Furthermore, the spread of \ac{SHO}-projectors can be specified using the keyword \ttt{sigma}.
The radius and spread are always given in \ttt{Bohr} atomic units!
\todo[inline]{Work on magnetism}
\noindent
When a magnetization is induced in the occupation numbers,
please make sure that the first number is the majority spin as e.g.~\ttt{5d* 5 1}.
Mind that currently only spin-paired atomic all-electron calculation can be performed by \ttt{atom\_core}.
%
To control the potential pseudization in the \ac{PAW} method we can insert 
\ttt{V=sinc} or \ttt{V=parabola} anywhere into the configuration string, no blank after \ttt{=}.
The advanced user can specify \ttt{numax} $\nu\um{max}$ to manipulate the size of the \ac{SHO}-projector basis
and adjust the number of protons \ttt{Zcore} $Z$, even non-integer.
%
%
%

\subsection{Automatic Element Config} \label{sec:element-config}
%
Mind that this is an experimental alternative to \ttt{sigma\_config} 
introduced in Section \ref{sec:sigma-config}.
Ensure that the \ttt{-D DEVEL} preprocessor flags is active and
\ttt{HAS\_ELEMENT\_CONFIG} is defined in \ttt{single\_atom.cxx}.
Use \ttt{+single\_atom.config=element} to activate it.
Control keywords are given in Table \ref{tab:element-config-variables}.
%
\begin{table}[h]
\caption[Element Config Variables]{
Control variables for \ttt{element\_config}
} \label{tab:element-config-variables}
\centering
\begin{tabular}{|r|l|l|r|}
\hline
  \# & Variable & Meaning & Default \\
\hline
 a) & \ttt{element\_}$Sy$\ttt{.rcut}         & \ac{PAW} augmentation radius in Bohr         & see h) \\
 b) & \ttt{element\_}$Sy$\ttt{.sigma}        & \ac{SHO} projector spread in Bohr            & see i) \\
 c) & \ttt{element\_}$Sy$\ttt{.numax}        & integer \ac{SHO} basis size                  & see j) \\
 d) & \ttt{element\_}$Sy$\ttt{.method}       & potential pseudization method                & see k) \\
 e) & \ttt{element\_}$Sy$\ttt{.hole.enn}     & core hole $n$                                & 0 \\
 f) & \ttt{element\_}$Sy$\ttt{.hole.ell}     & core hole $\ell$                             & -1 \\
 g) & \ttt{element\_}$Sy$\ttt{.hole.charge}  & core hole charge                             & 0.0 \\
 h) & \ttt{element\_config.rcut}             & Default for \ttt{element\_}$Sy$\ttt{.rcut}   & \unit[2.0]{Bohr} \\
 i) & \ttt{element\_config.sigma}            & Default for \ttt{element\_}$Sy$\ttt{.sigma}  & \unit[0.5]{Bohr} \\
 j) & \ttt{element\_config.numax}            & Default for \ttt{element\_}$Sy$\ttt{.numax}  & 3 \\
 k) & \ttt{element\_config.method}           & Default for \ttt{element\_}$Sy$\ttt{.method} & \ttt{sinc} \\
 l) & \ttt{element\_config.core.valence}     & Energy between core and valence bands        & \unit[-2.0]{Ha} \\
 m) & \ttt{element\_config.core.semicore}    & Energy between core and semicore bands       & see l) \\
 n) & \ttt{element\_config.semicore.valence} & Energy between semicore and valence bands    & see l) \\
\hline
\end{tabular}
\end{table}
%
If \ttt{single\_atom.core.state.localization} is not a positive number
the energy criterion is used to distinguish \ttt{core}, \ttt{semicore} and \ttt{valence} states.



% ==============================================================================
\bibliographystyle{plain} 
\bibliography{literature}
% ==============================================================================

\end{document}
